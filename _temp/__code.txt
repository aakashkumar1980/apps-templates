Yes! You can achieve this by:

1. Fetching SSL certificates from Vault and storing them temporarily in /tmp.


2. Configuring Kafka SSL properties dynamically in a @Configuration class.



Steps to Implement

1. Add Dependencies

Ensure you have dependencies for Spring Kafka and Vault:

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-kafka</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.vault</groupId>
    <artifactId>spring-vault-core</artifactId>
</dependency>

2. Vault Service to Fetch Files

Create a service to fetch SSL certificates from Vault and save them in /tmp.

import org.springframework.stereotype.Service;
import org.springframework.vault.core.VaultOperations;
import org.springframework.vault.support.VaultResponse;

import java.io.File;
import java.io.FileOutputStream;
import java.nio.charset.StandardCharsets;
import java.util.Map;

@Service
public class VaultSSLService {
    
    private final VaultOperations vaultOperations;
    private static final String TMP_DIR = "/tmp/";

    public VaultSSLService(VaultOperations vaultOperations) {
        this.vaultOperations = vaultOperations;
    }

    public String fetchAndStoreFile(String vaultPath, String fileName) throws Exception {
        VaultResponse response = vaultOperations.read(vaultPath);
        if (response == null || response.getData() == null) {
            throw new RuntimeException("Failed to retrieve data from Vault at " + vaultPath);
        }

        Map<String, Object> data = response.getData();
        if (!data.containsKey("content")) {
            throw new RuntimeException("No 'content' found in Vault response");
        }

        byte[] fileData = ((String) data.get("content")).getBytes(StandardCharsets.UTF_8);
        String filePath = TMP_DIR + fileName;

        try (FileOutputStream fos = new FileOutputStream(new File(filePath))) {
            fos.write(fileData);
        }

        return filePath;
    }
}

3. Kafka Configuration Using Vault SSL Files

Modify your Spring Kafka configuration to load SSL files dynamically.

import org.apache.kafka.clients.admin.AdminClientConfig;
import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.common.config.SslConfigs;
import org.apache.kafka.common.serialization.StringSerializer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.core.DefaultKafkaProducerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.core.ProducerFactory;

import java.util.HashMap;
import java.util.Map;

@Configuration
public class KafkaSSLConfig {

    private final VaultSSLService vaultSSLService;

    public KafkaSSLConfig(VaultSSLService vaultSSLService) {
        this.vaultSSLService = vaultSSLService;
    }

    @Bean
    public ProducerFactory<String, String> producerFactory() throws Exception {
        Map<String, Object> configProps = new HashMap<>();
        
        configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "your-kafka-broker:9093");

        // Fetch SSL files from Vault and store in /tmp
        String trustStorePath = vaultSSLService.fetchAndStoreFile("secret/kafka/truststore", "truststore.jks");
        String keyStorePath = vaultSSLService.fetchAndStoreFile("secret/kafka/keystore", "keystore.jks");

        // SSL Configurations
        configProps.put(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG, trustStorePath);
        configProps.put(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG, "your-truststore-password");

        configProps.put(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG, keyStorePath);
        configProps.put(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG, "your-keystore-password");
        configProps.put(SslConfigs.SSL_KEY_PASSWORD_CONFIG, "your-key-password");

        configProps.put("security.protocol", "SSL");

        // Serialization settings
        configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);

        return new DefaultKafkaProducerFactory<>(configProps);
    }

    @Bean
    public KafkaTemplate<String, String> kafkaTemplate() throws Exception {
        return new KafkaTemplate<>(producerFactory());
    }
}


---

How This Works

1. The VaultSSLService retrieves the SSL files (truststore.jks, keystore.jks) from Vault and saves them in /tmp.


2. The KafkaSSLConfig reads these files dynamically and configures Kafkaâ€™s producer factory.


3. Kafka is now configured to use the SSL files from Vault instead of hardcoding them in application.properties.



Next Steps

Ensure Vault is running and accessible.

Store SSL files in Vault under secret/kafka/truststore and secret/kafka/keystore, using content as the key.

If needed, enhance security by encrypting the stored files and using dynamic password retrieval.


Would you like help in setting up the Vault secrets?

