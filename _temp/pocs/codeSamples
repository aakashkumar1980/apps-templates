Got it! Below is the complete updated implementation based on your new requirements.


---

Step 1: Spring Boot Configuration (application.yml)

This configures Kafka consumers to process one message at a time with optimal settings.

spring:
  kafka:
    bootstrap-servers: kafka-broker:9092
    consumer:
      group-id: my-consumer-group
      enable-auto-commit: false
      max-poll-records: 1
      isolation-level: read_committed
      properties:
        session.timeout.ms: 30000
        heartbeat.interval.ms: 10000
        fetch.max.wait.ms: 500
        fetch.min.bytes: 1


---

Step 2: KafkaPartitionMapping Entity

Stores POD ID (1-8) and its assigned partitions in Couchbase.

import org.springframework.data.annotation.Id;
import org.springframework.data.couchbase.core.mapping.Document;
import java.util.List;

/**
 * Represents a mapping between a unique POD ID and assigned Kafka partitions.
 */
@Document
public class KafkaPartitionMapping {

    @Id
    private Integer podId; // Unique ID (1-8) for main PODs

    private List<Integer> partitions; // Assigned partitions (each gets 3)

    public KafkaPartitionMapping() {}

    public KafkaPartitionMapping(Integer podId, List<Integer> partitions) {
        this.podId = podId;
        this.partitions = partitions;
    }

    public Integer getPodId() { return podId; }
    public void setPodId(Integer podId) { this.podId = podId; }

    public List<Integer> getPartitions() { return partitions; }
    public void setPartitions(List<Integer> partitions) { this.partitions = partitions; }
}


---

Step 3: KafkaPartitionRepository

Handles partition assignments in Couchbase.

import org.springframework.data.couchbase.repository.CouchbaseRepository;
import org.springframework.stereotype.Repository;
import java.util.Optional;

/**
 * Repository to manage POD-to-partition mappings.
 */
@Repository
public interface KafkaPartitionRepository extends CouchbaseRepository<KafkaPartitionMapping, Integer> {
    
    Optional<KafkaPartitionMapping> findById(Integer podId);
}


---

Step 4: Health Check & POD Registration

Manages health checks and assigns new PODs if an existing one crashes.

import org.springframework.stereotype.Service;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Manages Kafka partition assignments and POD registration.
 */
@Service
public class KafkaPartitionService {

    private final KafkaPartitionRepository partitionRepository;
    private final PodHealthCheckService healthCheckService;
    private final UniquePodIdService uniquePodIdService;

    public KafkaPartitionService(KafkaPartitionRepository partitionRepository, 
                                 PodHealthCheckService healthCheckService,
                                 UniquePodIdService uniquePodIdService) {
        this.partitionRepository = partitionRepository;
        this.healthCheckService = healthCheckService;
        this.uniquePodIdService = uniquePodIdService;
    }

    /**
     * Registers a POD and assigns partitions if not already assigned.
     */
    public void registerPod() {
        Integer podId = uniquePodIdService.getPodId();
        if (podId == null || podId > 8) {
            System.out.println("This POD is not part of the 8 designated instances. Skipping registration.");
            return;
        }

        Optional<KafkaPartitionMapping> existingMapping = partitionRepository.findById(podId);

        if (existingMapping.isEmpty() || !healthCheckService.isPodAlive(podId)) {
            List<Integer> assignedPartitions = List.of((podId - 1) * 3, (podId - 1) * 3 + 1, (podId - 1) * 3 + 2);
            KafkaPartitionMapping newMapping = new KafkaPartitionMapping(podId, assignedPartitions);
            partitionRepository.save(newMapping);
            System.out.println("Registered POD " + podId + " with partitions: " + assignedPartitions);
        } else {
            System.out.println("POD " + podId + " is already registered.");
        }
    }
}


---

Step 5: Health Check Service

Ensures crashed PODs are removed before registering a new one.

import org.springframework.stereotype.Service;
import java.util.List;

/**
 * Checks the health of registered PODs.
 */
@Service
public class PodHealthCheckService {

    /**
     * Mock function: Replace with actual API calls to check if a POD is alive.
     */
    public boolean isPodAlive(Integer podId) {
        // Implement real health-check API call here
        return Math.random() > 0.1; // Simulating 10% failure rate
    }
}


---

Step 6: Unique POD ID Service

Ensures correct POD registration.

import org.springframework.stereotype.Service;

/**
 * Service to determine the unique ID for the running POD.
 */
@Service
public class UniquePodIdService {

    /**
     * Retrieves the unique POD ID from an environment variable.
     */
    public Integer getPodId() {
        String podIdStr = System.getenv("POD_ID");
        return podIdStr != null ? Integer.parseInt(podIdStr) : null;
    }
}


---

Step 7: Kafka Consumer Configuration

Listens for messages and ensures manual acknowledgment.

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.support.Acknowledgment;
import org.springframework.stereotype.Service;

/**
 * Kafka Consumer Service that listens to assigned partitions.
 */
@Service
public class KafkaConsumerService {

    private final UniquePodIdService uniquePodIdService;
    private final KafkaPartitionService kafkaPartitionService;

    public KafkaConsumerService(UniquePodIdService uniquePodIdService, 
                                KafkaPartitionService kafkaPartitionService) {
        this.uniquePodIdService = uniquePodIdService;
        this.kafkaPartitionService = kafkaPartitionService;
    }

    @KafkaListener(topics = "my-kafka-topic", groupId = "my-consumer-group", concurrency = "1")
    public void listen(ConsumerRecord<String, String> record, Acknowledgment ack) {
        Integer podId = uniquePodIdService.getPodId();

        if (podId == null || podId > 8) {
            System.out.println("This POD is not one of the assigned processing instances. Skipping message.");
            return;
        }

        kafkaPartitionService.registerPod();

        System.out.println("Processing message on POD " + podId + ": " + record.value());
        
        // Simulate processing time
        try {
            Thread.sleep(1000);
        } catch (InterruptedException ignored) {}

        ack.acknowledge(); // Manually acknowledge message
    }
}


---

Final Notes

1. Partitioning Strategy

Each POD (1-8) gets exactly 3 partitions.

Example: POD 1 → Partitions [0,1,2], POD 2 → [3,4,5], ..., POD 8 → [21,22,23].



2. POD Registration & Fault Tolerance

Registers only the first 8 PODs.

If a POD crashes, it reclaims the same ID.

A health check verifies the existing POD status before assigning a new one.



3. Kafka Consumer Optimization

One message at a time per POD (max-poll-records: 1).

Manual acknowledgment (enable-auto-commit: false).

Concurrency set to 1 (concurrency: 1 in @KafkaListener).





---

How This Works

1. Environment variable (POD_ID) determines each POD's unique ID.


2. PODs 1-8 are registered in Couchbase and mapped to partitions.


3. If a POD crashes, a health check replaces it with a new one.


4. Only 8 PODs process Kafka messages; the others remain idle.


5. Consumers process one message at a time and acknowledge manually.




---

This should fully align with your requirements! Let me know if you need any further refinements.

