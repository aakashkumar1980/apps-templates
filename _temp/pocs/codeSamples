Thank you for the clarification. I now understand that in Kafka 3.1.1, groupSubscription() returns a Map<String, Subscription> where each Subscription contains the topics that the consumer is subscribed to and additional metadata. My earlier response was incorrect in assuming the structure of GroupSubscription.

Let's correct the implementation accordingly, using the Subscription object properly.

Corrected Implementation for Kafka 3.1.1:

Since groupSubscription() returns a map of String to Subscription, we need to extract the topic partitions from the Subscription object and assign partitions accordingly.

Here's the updated version of the CustomPartitionAssignor class:

Custom Partition Assignor for Kafka 3.1.1:

import org.apache.kafka.clients.consumer.ConsumerPartitionAssignor;
import org.apache.kafka.clients.consumer.GroupSubscription;
import org.apache.kafka.clients.consumer.Subscription;
import org.apache.kafka.common.Cluster;
import org.apache.kafka.common.TopicPartition;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class CustomPartitionAssignor implements ConsumerPartitionAssignor {

    private Integer id;

    // Constructor that accepts the dynamic 'id'
    public CustomPartitionAssignor(Integer id) {
        this.id = id;
    }

    @Override
    public GroupAssignment assign(Cluster metadata, GroupSubscription groupSubscription) {
        // List to store the assigned partitions for each consumer
        List<TopicPartition> assignedPartitions = new ArrayList<>();

        // Loop through each consumer in the group subscription
        for (Map.Entry<String, Subscription> entry : groupSubscription.groupSubscription().entrySet()) {
            String consumerId = entry.getKey();
            Subscription subscription = entry.getValue();

            // For each consumer, determine how to assign partitions
            List<String> topics = subscription.topics();
            for (String topic : topics) {
                // For each topic, assign a partition based on the dynamic 'id'
                int numPartitions = metadata.partitionCountForTopic(topic);
                int partition = (id - 1) % numPartitions;  // Ensure 1-to-1 assignment (id starts from 1)

                // Assign the partition to this consumer's topic
                assignedPartitions.add(new TopicPartition(topic, partition));
            }
        }

        // Return the group assignment
        return new GroupAssignment(assignedPartitions);
    }

    @Override
    public String name() {
        return "CustomPartitionAssignor";
    }
}

Explanation of Changes:

1. groupSubscription():

groupSubscription() returns a Map<String, Subscription>, where the key is the consumer ID (or client ID) and the value is the Subscription object. The Subscription object contains the list of topics this consumer is subscribed to.



2. Topic Partition Assignment:

For each consumer in the group, we loop over their subscriptions (topics they are subscribed to).

For each topic, we calculate the number of partitions available using metadata.partitionCountForTopic(topic).

The partition is assigned based on the pod-specific id using (id - 1) % numPartitions, ensuring that each pod gets a specific partition.



3. GroupAssignment:

After calculating the partition for each consumer, we collect them in a list of TopicPartition objects.

Finally, we return the GroupAssignment that Kafka uses to assign partitions to the consumers.




Example Usage:

When setting up the consumer, you still need to ensure that your consumer configuration uses the custom CustomPartitionAssignor class.

// Retrieve the pod-specific ID dynamically (e.g., from your DB call)
Integer id = idService.getId();  // Get the unique pod ID, e.g., 1, 2, etc.

// Create a custom partition assignor instance with the retrieved 'id'
CustomPartitionAssignor customAssignor = new CustomPartitionAssignor(id);

Properties properties = new Properties();
properties.put("bootstrap.servers", "localhost:9092");
properties.put("group.id", "my-consumer-group");
properties.put("enable.auto.commit", "false");
properties.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
properties.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
properties.put("partition.assignment.strategy", customAssignor.getClass().getName());

KafkaConsumer<String, String> consumer = new KafkaConsumer<>(properties);
consumer.subscribe(Collections.singletonList("my-topic"));

Final Notes:

Dynamic Assignment: The partition for each pod is assigned dynamically based on the id, using modulo arithmetic to map the id to a valid partition number.

Subscription: Each consumer's subscriptions are handled independently, ensuring each pod gets the appropriate partition based on its id.

Partition Validation: We use metadata.partitionCountForTopic(topic) to ensure that we don't assign a partition outside the valid range.


This updated implementation correctly handles the changes in Kafka 3.1.1 and makes partition assignment dynamic using the id passed to the custom partition assignor.

